import os
import subprocess
import numpy as np
import periodictable as pt


def set_name_file(ion, target_elements):
    name = ion[0] + "---"
    for e in target_elements:
        name += e[0]
        if e[1] > 1:
            name += str(e[1])
    name += ".rangedata"
    return name


def get_density(name_material):
    """
    fetches and returns material density from predefined dictionary
    Args:
        name_material (str): name of material

    Returns:
        float: density in g/cm3

    """
    densities = {
        "SiO2": 2.196,
        "Si": 2.33,
        "Si3N4": 3.44,
        "GaAs": 5.3176,
        "Ge": 5.323,
        "HfO2": 9.68,
        "C": 2.0,       # amorphous carbon
        "Cu": 8.96,
        "Copper": 8.96,
        "Ag": 10.49,
        }
    return densities[name_material]


def get_composition(symbol):
    target_elements = []
    element = [0, 0]

    for c in symbol:

        # check if capitol letter or number
        if c == c.upper() and not c.isnumeric():
            target_elements.append(element)
            target_elements[-1] = [c, 1]
        if c == c.lower() and not c.isnumeric():
            target_elements[-1][0] += c
        if c.isnumeric():
            target_elements[-1][1] = int(c)
    return target_elements


def create_input_file(path_file_in, ion, energy_ion_min, energy_ion_max,
                      target_density, target_compound_correction, target_elements, target_solid=0,
                      name_file_out=False):
    """
    creates input file for SRIM "SR.IN" used to run SRIM cases
    Args:
        path_file_in (str): path where input file is saved (including name)
        ion (tuple): contains basic ion information (name, mass, atomic number)
        energy_ion_min (float): minimum energy for sweep (keV)
        energy_ion_max (float): maximum energy for sweep (keV)
        target_density (float): mass density of target (g/cm)
        target_compound_correction (float): correction factor to account for compound effects
        target_elements (list[tuple[str, float]]: list of tuples with target material name and stochiometric fraction
        target_solid (int): 0 if solid target 1 if not
        name_file_out (float): name for output file (optional, autogenerated if not passed)
    """
    # unpack ion
    ion_name = ion[0]
    ion_m = ion[1]
    ion_z = ion[2]

    f = open(path_file_in, "w")
    f.write("---Stopping/Range Input Data (Number-format: Period = Decimal Point)\n" +
            "---Output File Name\n")
    # get output file name
    if name_file_out:
        name_file_out = str(name_file_out)
    else:
        name_file_out = f"{ion_name} in "
        for t in target_elements:
            name_file_out += f" {t[0]}"
    f.write(f'"{name_file_out}"\n')
    f.write("---Ion(Z), Ion Mass(u)\n")
    f.write(f"{ion_z}  {ion_m}\n")
    f.write("---Target Data: (Solid=0,Gas=1), Density(g/cm3), Compound Corr.\n")
    f.write(f"{target_solid}   {target_density}   {target_compound_correction}\n")
    f.write("---Number of Target Elements\n")
    f.write(f"{len(target_elements)}\n")
    f.write(f"---Target Elements: (Z), Target name, Stoich, Target Mass(u)\n")
    # fetch target element data from periodic table module and write to file
    for e in target_elements:
        # atomic number
        z = str(eval(f"pt.{e[0]}.number"))
        m = str(eval(f"pt.{e[0]}.mass"))
        f.write(f'{z}   "{e[0]}"   {e[1]}   {m}\n')
    f.write(f"---Output Stopping Units(1 - 8)\n 5\n")
    f.write(f"---Ion Energy : E-Min(keV), E-Max(keV)\n")
    f.write(f"{energy_ion_min}  {energy_ion_max}\n")

    f.close()

    return name_file_out


def read_output_file(path_file_out):
    """
    reads in SRIM- output file and raturns array with results
    Array columns:
        energy (eV)     erange (nm)      long. straggle (nm)     lat. straggle (nm)
    Args:
        path_file_out (str): path to file

    Returns:
        np.ndarray:  data array
    """
    # identify data lines
    f = open(path_file_out, "r")
    # find table marker '-----------'
    srim_table = False
    array_out = np.zeros(4)
    for line in f:
        if '-----------' in line and not srim_table:
            srim_table = True
            continue
        if '-----------' in line and srim_table:
            break
        if srim_table:
            line_list = line.split()
            energy = float(line_list[0])
            if line_list[1] == "keV":
                energy = energy * 1000
            elif line_list[1] == "MeV":
                energy = energy * 1000000

            erange = float(line_list[4])
            if line_list[5] == "A":
                erange = erange / 10
            elif line_list[5] == "um":
                erange = erange * 1000

            long_straggle = float(line_list[6])
            if line_list[7] == "A":
                long_straggle = long_straggle / 10
            elif line_list[7] == "um":
                long_straggle = long_straggle * 1000

            lat_straggle = float(line_list[8])
            if line_list[9] == "A":
                lat_straggle = lat_straggle / 10
            if line_list[9] == "um":
                lat_straggle = lat_straggle * 1000

            row = np.array([energy, erange, long_straggle, lat_straggle])
            # print(row)
            array_out = np.vstack([array_out, row])
    # remove first dummy line of array
    array_out = array_out[1:, :]

    # interpolate

    for column in [1, 2, 3]:
        last_val = 0.0
        consecutive = 1
        for i, val in enumerate(array_out[:, column]):
            if val == last_val:
                consecutive += 1
                continue

            last_val = val
            if consecutive > 1:
                val_left = array_out[i-consecutive, column]
                val_right = array_out[i, column]
                delta = (val_right-val_left)/consecutive

                for idx_back in range(consecutive):
                    array_out[(i-idx_back), column] = round((val_right - (idx_back * delta)), 4)
            consecutive = 1

    return array_out


def get_mass(element_symbol):
    """
    fetches atomic mass in amu of element using the periodictable module
    Args:
        element_symbol (str): Element symbol

    Returns:
        float: mass (amu)
    """
    mass = eval(f"pt.{element_symbol}.mass")
    return mass


def get_z(element_symbol):
    """
    fetches atomic number of element using the periodictable module
    Args:
        element_symbol (str): Element symbol

    Returns:
        int: atomic number
    """
    z = eval(f"pt.{element_symbol}.number")
    return z


def run(ion_name, target_material, save_file=False):
    """
    run SRIM and extract run data from its output file
    Args:
        ion_name (str): name of incident ion
        target_material (str): name of target material
        save_file (bool): save additional  singular output file

    Returns:

    """
    # directory and path config
    dir_srim_module = os.path.abspath("SRIM_Module")
    path_srim_module = os.path.join(dir_srim_module, "SRModule.exe")
    path_srim_in = os.path.join(dir_srim_module, "SR.IN")
    dir_data = os.path.join(os.getcwd(), "Data")

    # sample energy (keV)
    energy_min = 0.02
    energy_max = 500

    density = get_density(target_material)

    # target element and stochiometric composition
    target_elements = get_composition(target_material)

    print("-----------------------------------------------")
    print(f"Ion: {ion_name}")
    print(f"target material: {target_material}")
    print(f"target material composition: {target_elements}")
    print(f"target density: {density} g/cm3")

    # pack ion variable
    ion = (ion_name, get_mass(ion_name), get_z(ion_name))

    # create SRIM input file and save output file name
    name_file_out = create_input_file(path_srim_in, ion, energy_min, energy_max, density,  0.0, target_elements)

    path_file_out = os.path.join(dir_srim_module, name_file_out)

    # run SRIM module
    subprocess.run(path_srim_module, cwd=dir_srim_module)

    # read SRIM output file
    data_run = read_output_file(path_file_out)

    # save SRIM output data to output file
    if save_file:
        path_file_data = os.path.join(dir_data, set_name_file(ion, target_elements))
        np.savetxt(path_file_data, data_run)

    return data_run


def append_to_data_file(path, data, target, ion):
    """
    append range data to data file
    Args:
        path (str): path to data file
        data (np.ndarray): 2D data array
        target (str): name of target material
        ion (str): name of incident ion
    """
    f = open(path, 'a')
    f.write(f"Target: {target}, Ion: {ion}\n")
    f.write("----------------------------\n")
    for row in data:
        for element in row:
            f.write(f"{element:.2f}, ")
        f.write("\n")
    f.write("\n")
    f.close()


def initialize_data_file(path):
    if os.path.exists(path):
        os.remove(path)
    f = open(path, 'w')
    f.write(f"incident energy (eV), projected range (nm), longitudinal straggle (nm), lateral straggle (nm),\n")
    f.write("===============================================================================================\n\n")
    f.close()
